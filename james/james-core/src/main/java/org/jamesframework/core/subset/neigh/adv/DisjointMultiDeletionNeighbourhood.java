/*
 * Copyright 2014 Ghent University, Bayer CropScience.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.jamesframework.core.subset.neigh.adv;

import java.util.ArrayList;
import java.util.Collections;
import org.jamesframework.core.subset.neigh.moves.GeneralSubsetMove;
import java.util.List;
import java.util.Random;
import java.util.Set;
import java.util.concurrent.ThreadLocalRandom;
import java.util.stream.IntStream;
import org.jamesframework.core.subset.SubsetSolution;
import org.jamesframework.core.subset.neigh.SingleDeletionNeighbourhood;
import org.jamesframework.core.subset.neigh.moves.SubsetMove;
import org.jamesframework.core.subset.neigh.SubsetNeighbourhood;
import org.jamesframework.core.util.SetUtilities;
import org.jamesframework.core.util.SubsetIterator;

/**
 * <p>
 * A subset neighbourhood that generates moves which simultaneously remove a fixed number of items from the selection.
 * Generated moves are of type {@link GeneralSubsetMove}, which is a subtype of {@link SubsetMove}, and always only
 * remove IDs from the selection. If desired, a set of fixed IDs can be provided which are not allowed to be removed.
 * Also, a minimum size can be imposed so that it is guaranteed that the subset size will not drop below this minimum
 * after application of a move generated by this neighbourhood. It may happen to be impossible to perform the desired
 * number of deletions, e.g. because too few items are selected or because of the imposed minimum subset size. In such
 * case a lower number of items will be removed (as many as possible).
 * </p>
 * <p>
 * Note that a large amount of moves may be generated when the subset size increases. Therefore, this
 * advanced neighbourhood should be used with care, especially in combination with searches that inspect
 * all moves in every step. Furthermore, searches that inspect random moves may have few chances to find an
 * improvement in case of a huge amount of possible neighbours.
 * </p>
 * <p>
 * This neighbourhood is thread-safe: it can be safely used to concurrently generate moves in different searches
 * running in separate threads.
 * </p>
 * 
 * @author <a href="mailto:herman.debeukelaer@ugent.be">Herman De Beukelaer</a>
 */
public class DisjointMultiDeletionNeighbourhood extends SubsetNeighbourhood {

    // fixed number of simultaneous removals
    private final int numDeletions;
    // minimum subset size
    private final int minSubsetSize;
    
    /**
     * Creates a disjoint multi deletion neighbourhood that simultaneously removes a fixed number of
     * IDs from the selection. If <code>numDeletions</code> is 1, this neighbourhood generates exactly the
     * same moves as the {@link SingleDeletionNeighbourhood} so in such case it is advised to use the latter
     * neighbourhood which has been optimized for this specific scenario.
     * 
     * @param numDeletions fixed number of removed IDs (&gt; 0)
     * @throws IllegalArgumentException if <code>numDeletions</code> is not strictly positive
     */
    public DisjointMultiDeletionNeighbourhood(int numDeletions){
        this(numDeletions, 0);
    }
    
    /**
     * Creates a disjoint multi deletion neighbourhood that simultaneously removes a fixed number of
     * IDs from the selection, taking into account that the subset size may not drop below the given minimum.
     * If <code>numDeletions</code> is 1, this neighbourhood generates exactly the same moves as the
     * {@link SingleDeletionNeighbourhood} so in such case it is advised to use the latter neighbourhood
     * which has been optimized for this specific scenario.
     * 
     * @param numDeletions fixed number of removed IDs (&gt; 0)
     * @param minSubsetSize minimum subset size (&ge; 0)
     * @throws IllegalArgumentException if <code>numDeletions</code> is not strictly positive
     *                                  or <code>minSubsetSize</code> is negative
     */
    public DisjointMultiDeletionNeighbourhood(int numDeletions, int minSubsetSize){
        this(numDeletions, minSubsetSize, null);
    }
    
    /**
     * Creates a disjoint multi deletion neighbourhood that simultaneously removes a fixed number of
     * IDs from the selection, taking into account that the subset size may not drop below the given minimum
     * and that the given set of fixed IDs are not allowed to be deselected. If <code>numDeletions</code>
     * is 1, this neighbourhood generates exactly the same moves as the {@link SingleDeletionNeighbourhood}
     * so in such case it is advised to use the latter neighbourhood which has been optimized for this
     * specific scenario.
     * 
     * @param numDeletions fixed number of removed IDs (&gt; 0)
     * @param minSubsetSize minimum subset size (&ge; 0)
     * @param fixedIDs set of fixed IDs which are not allowed to be removed from the selection
     * @throws IllegalArgumentException if <code>numDeletions</code> is not strictly positive
     *                                  or <code>minSubsetSize</code> is negative
     */
    public DisjointMultiDeletionNeighbourhood(int numDeletions, int minSubsetSize, Set<Integer> fixedIDs){
        super(fixedIDs);
        // check number of deletions
        if(numDeletions <= 0){
            throw new IllegalArgumentException("The number of deletions should be strictly positive.");
        }
        if(minSubsetSize < 0){
            throw new IllegalArgumentException("The minimum subset size should be non-negative.");
        }
        this.numDeletions = numDeletions;
        this.minSubsetSize = minSubsetSize;
    }

    /**
     * Get the fixed number of deletions performed by generated moves.
     * 
     * @return fixed number of deletions
     */
    public int getNumDeletions() {
        return numDeletions;
    }
    
    /**
     * Get the minimum subset size specified at construction.
     * If no minimum size has been set this method returns 0.
     * 
     * @return minimum subset size
     */
    public int getMinSubsetSize() {
        return minSubsetSize;
    }
    
    /**
     * Generates a move for the given subset solution that deselects a random subset of currently selected IDs.
     * Whenever possible, the requested number of deletions is performed. However, taking into account the current
     * number of selected items, the imposed minimum subset size (if set) and the fixed IDs (if any) may result in
     * fewer deletions (as many as possible). If no items can be removed, <code>null</code> is returned.
     * 
     * @param solution solution for which a random multi deletion move is generated
     * @return random multi deletion move, <code>null</code> if no items can be removed
     */
    @Override
    public SubsetMove getRandomMove(SubsetSolution solution) {
        // get set of candidate IDs for deletion (fixed IDs are discarded)
        Set<Integer> delCandidates = getRemoveCandidates(solution);
        // compute number of deletions
        int curNumDel = numDeletions(delCandidates, solution);
        // return null if no removals are possible
        if(curNumDel == 0){
            return null;
        }
        // use thread local random for better concurrent performance
        Random rg = ThreadLocalRandom.current();
        // pick random IDs to remove from selection
        Set<Integer> del = SetUtilities.getRandomSubset(delCandidates, curNumDel, rg);
        // create and return move
        return new GeneralSubsetMove(Collections.emptySet(), del);
    }

    /**
     * <p>
     * Generates the list of all possible moves that perform \(k\) deletions, where \(k\) is the fixed number
     * specified at construction. Note: taking into account the current number of selected items, the imposed
     * minimum subset size (if set) and the fixed IDs (if any) may result in fewer deletions (as many as possible).
     * </p>
     * <p>
     * May return an empty list if no moves can be generated.
     * </p>
     * 
     * @param solution solution for which all possible multi deletion moves are generated
     * @return list of all multi deletion moves, may be empty
     */
    @Override
    public List<SubsetMove> getAllMoves(SubsetSolution solution) {
        // create empty list to store generated moves
        List<SubsetMove> moves = new ArrayList<>();
        // get set of candidate IDs for removal (fixed IDs are discarded)
        Set<Integer> delCandidates = getRemoveCandidates(solution);
        // compute number of deletions
        int curNumDel = numDeletions(delCandidates, solution);
        if(curNumDel == 0){
            // impossible: return empty set
            return moves;
        }
        // create all moves that remove curNumDel items
        Set<Integer> del;
        SubsetIterator<Integer> itDel = new SubsetIterator<>(delCandidates, curNumDel);
        while(itDel.hasNext()){
            del = itDel.next();
            // create and add move
            moves.add(new GeneralSubsetMove(Collections.emptySet(), del));
        }
        // return all moves
        return moves;
    }
    
    /**
     * Computes the number of deletions that are to be performed, given the set of remove candidates
     * and the current subset solution. Takes into account the desired number of deletions \(k\)
     * specified at construction, the number of currently selected non-fixed items and the minimum
     * allowed subset size (if any).
     * 
     * @param remCandidates candidate IDs to be removed from the selection
     * @param sol subset solution for which moves are being generated
     * @return number of deletions to be performed
     */
    private int numDeletions(Set<Integer> remCandidates, SubsetSolution sol){
        int d = IntStream.of(numDeletions, remCandidates.size(), sol.getNumSelectedIDs()-minSubsetSize).min().getAsInt();
        return Math.max(d, 0);
    }

}
